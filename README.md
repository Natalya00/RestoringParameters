# Восстановление параметров Земли, Луны и Солнца. #

## Описание
В коде реализовано численное моделирование гравитационного взаимодействия системы Солнце-Земля-Луна. Программа позволяет рассчитать траектории движения небесных тел, учитывая их массы и начальные условия. После численного моделирования на полученные данные накладывается шум. Затем с использованием метода Гаусса-Ньютона проводится восстановление истинных параметров системы, включая начальные массы тел. Результаты визуализируются, что позволяет наблюдать динамику движения небесных тел и оценить точность восстановления параметров.

## Оглавление
1. Описание кода 
   * Используемые константы и начальные условия
   * Основные функции для расчета физических величин
   * Метод Дормана-Принса
   * Основная часть программы
   * Восстановление параметров
   * Визуализация
2. Математические выкладки
3. Результаты

## 1. Описание кода
### Используемые константы и начальные условия
```
G = 2.95912208286e-4  # Гравитационная постоянная
m0 = 1.0  # Масса Солнца
m1 = 3.00348959632E-6  # Масса Земли
m2 = m1 * 1.23000383E-2  # Масса Луны
```
**G** — гравитационная постоянная в астрономических единицах (AU³/год²/масса Солнца).  
**m0, m1, m2** — массы Солнца, Земли и Луны. Массы Земли и Луны заданы относительно массы Солнца для удобства расчетов.

```
q0 = np.array([
    [0, 0, 0],  # Солнце
    [-0.1667743823220, 0.9690675883429, -0.0000342671456],  # Земля
    [-0.1694619061456, 0.9692330175719, -0.0000266725711]  # Луна
])
v0 = np.array([
    [0, 0, 0],  # Солнце
    [-0.0172346557280, -0.0029762680930, -0.0000004154391],  # Земля
    [-0.0172817331582, -0.0035325102831, 0.0000491191454]  # Луна
])
p0 = np.array([
    v0[0] * m0, # Солнце
    v0[1] * m1, # Земля
    v0[2] * m2  # Луна
])
```
**q0, v0, p0** — начальные положения, скорости и импульсы для Солнца, Земли и Луны в астрономических единицах (AU).

### Основные функции для расчета физических величин
#### Нормализация веторов
```
def vecf(v):
    return v / norm(v) ** 3
```
Функция нормализует вектор и делит его на куб его длины, что соответствует физической модели гравитационного притяжения, где сила обратно пропорциональна квадрату расстояния, а для вычисления направления силы используется единичный вектор, направленный по линии соединения объектов.
#### Закон Всемирного тяготения
```
def fun_v(q):
    f = np.zeros((3, 3))
    f[0] = -G * m0 * m1 * vecf(q[0] - q[1]) - G * m0 * m2 * vecf(q[0] - q[2])
    f[1] = -G * m1 * m0 * vecf(q[1] - q[0]) - G * m1 * m2 * vecf(q[1] - q[2])
    f[2] = -G * m2 * m0 * vecf(q[2] - q[0]) - G * m2 * m1 * vecf(q[2] - q[1])
    return f
```
Функция вычисляет гравитационные силы, действующие на Солнце, Землю и Луну, на основе закона всемирного тяготения Ньютона.
Силы рассчитываются как векторные суммы для каждой пары тел (Солнце-Земля, Солнце-Луна, Земля-Луна).
Таким образом, эта функция возвращает массив сил, действующих на каждый объект в системе, и представляет собой динамическую модель взаимодействия между Солнцем, Землей и Луной.

#### Закон движения Ньютона
```
def fun_u(p):
    return np.array([p[0] / m0, p[1] / m1, p[2] / m2])
```
Функция fun_u возвращает скорости тел на основе их импульсов. Функция использует импульсы, переданные вектору p, и делит их на соответствующие массы для вычисления скоростей тел. Эта функция является практическим применением второго закона Ньютона, который связывает импульс тела с его движением.
Таким образом, функция находит скорости тел на основе их импульсов, что необходимо для обновления их положения на каждом шаге численного интегрирования.

### Метод Дормана-Принса
Метод Дорманда-Принса используется для интегрирования системы дифференциальных уравнений.  
Аргументы: временной интервал, начальный шаг интегрирования (h_0), начальные значения координат (q) и импульсов (p).  
Внутри метода выполняются 7 стадий (k1_q, k1_p, ..., k7_q, k7_p) для вычисления промежуточных значений координат и импульсов.
После каждой стадии вычисляется новое значение q_next и p_next.
Оценивается локальная ошибка (error) и корректируется шаг интегрирования h на основе заданной точности tol.
Если ошибка превышает заданную точность (error > tol), шаг уменьшается (h = h * 0.9 * (tol / error) ** 0.2).
Если ошибка значительно меньше заданной точности, шаг увеличивается (h = min(h * 2, h0)).  
Результаты интегрирования сохраняются в списки vq (координаты) и vp (импульсы).

### Основная часть программы
Содержит основную логику программы. 
```
time_span = int(365) # Интервал времени моделирования (365 дней)
h = 1 # Начальный шаг интегрирования
true_vp, true_vq, _ = dormand_prince(time_span, h, p0, q0) # Численное моделирование
```
Задаются начальные параметры, после чего используется метод Дорманда-Принса для вычисления истинных координат и импульсов тел на заданном интервале времени.

```
noise_level = 1 # Уровень шума
# Наблюдаемые массы тел с добавлением нормально распределенного шума
m0_obs = m0 + np.random.normal(0, noise_level)
m1_obs = m1 + np.random.normal(0, noise_level)
m2_obs = m2 + np.random.normal(0, noise_level)
# Массив масс с наложенным шумом
masses_obs = np.array([m0_obs, m1_obs, m2_obs])
# Импульсы с наложением шума
vp_obs = true_vp + np.random.normal(0, noise_level, true_vp.shape)
# Координаты тел с наложением шума
vq_obs = true_vq + np.random.normal(0, noise_level, true_vq.shape)
```
На истинные значения накладывается шум.

```
vp_restored, vq_restored, masses_restored = gauss_newton(true_vp, true_vq, masses_true, vp_obs, vq_obs, masses_obs)
```
Используется метод Гаусса-Ньютона для восстановления истинных координат, импульсов и масс на основе зашумленных данных.

```
plot_3d_vp_vq(vq_restored)
```
Функция для построения 3D-графика восстановленных траекторий тел.

```
print("\nВосстановленные массы:", masses_restored)
print("Истинные массы:", masses_true)
print("\nВосстановленные динамические параметры:")
print(f"Импульсы vp: {vp_restored}")
print(f"Координаты vq: {vq_restored}")
```
Выводятся восстановленные массы, импульсы и координаты, а также их ошибки относительно истинных значений.
После чего происходит визуализация движения тел по восстановленным параметрам.

### Восстановление параметров
Для восстановления истинных значений параметров применяется метод Гаусса-Ньютона. Метод используется для минимизации квадратичной ошибки (невязки) между наблюдаемыми и истинными значениями параметров.
#### Функция для вычисления невязок
```
def compute_residual(vp_obs, vq_obs, true_vp, true_vq, masses_obs, true_masses):
    res_p = true_vp - vp_obs
    res_q = true_vq - vq_obs
    res_masses = true_masses - masses_obs
    return np.concatenate((res_p.flatten(), res_q.flatten(), res_masses))
```
Вычисляет невязки (остаточные ошибки) между наблюдаемыми (**vp_obs, vq_obs, masses_obs**) и истинными значениями (**true_vp, true_vq, true_masses**).
Возвращает вектор остаточных ошибок, объединенный из ошибок для импульсов, координат и масс.

#### Функция для вычисления Якобиана
```
def compute_jacobian(f, x, epsilon=1e-6):
    n = len(x)
    J = np.zeros((len(f(x)), n))
    for i in range(n):
        x_perturbed = x.copy()
        x_perturbed[i] += epsilon
        J[:, i] = (f(x_perturbed) - f(x)) / epsilon
    return J
```
Якобиан – это матрица производных, которая описывает изменение функции при изменении параметров.
Для вычисления Якобиана используется численный метод конечных разностей. Этот метод основан на аппроксимации частных производных функции через её изменения при небольших возмущениях аргументов.  
**f** – функция, для которой вычисляется Якобиан.  
**x** – точка, в которой вычисляется Якобиан.  
**epsilon** – шаг для численного дифференцирования.  
Возвращает матрицу Якобиана **J**, где каждый столбец соответствует частной производной функции **f** по соответствующей переменной.

#### Функция, выполняющая LU-разложение матрицы
```
def lu_decomposition(A):
    n = A.shape[0]
    L = np.zeros((n, n))
    U = np.zeros((n, n))

    for i in range(n):
        # Верхняя треугольная матрица (U)
        for k in range(i, n):
            U[i, k] = A[i, k] - np.dot(L[i, :i], U[:i, k])

        # Нижняя треугольная матрица (L)
        for k in range(i, n):
            if i == k:
                L[i, i] = 1
            else:
                L[k, i] = (A[k, i] - np.dot(L[k, :i], U[:i, i])) / U[i, i]
    return L, U
```
Выполняет LU-разложение матрицы **A**, то есть разложение её на две матрицы:
**L** (нижняя треугольная матрица) и
**U** (верхняя треугольная матрица), так что:
**A = L * U**.  
Нижняя треугольная матрица **L** имеет единицы на главной диагонали, элементы ниже диагонали могут быть любыми. 
Верхняя треугольная матрица **U** имеет элементы, равные 0, ниже диагонали.  
Создаются две пустые матрицы **L и U**, заполненные нулями.
Заполняется верхняя треугольная матрица **U**: элементы U[i; k] для текущей строки i и всех столбцов k ≥ i вычисляются по формуле: U[i; k] = A[i; k] - sum(L[i; p] * U[p;k]).
Заполняется нижняя треугольная матрица **L**: элементы L[k; i] для текущего столбца i и всех строк k ≥ i вычисляются по формуле: L[k; i] = (A[k; i] - sum(L[k; p] * U[p;i])) / U[i; i]. Диагональные элементы L[i,i]=1 задаются явно.
Возвращает матрицы **L и U**.

#### Функция, выполняющая решение системы линейных уравнений Ax = b.
```
def solve_lu(L, U, b):
    n = L.shape[0]

    # Прямая подстановка: решаем Ly = b
    y = np.zeros(n)
    for i in range(n):
        y[i] = b[i] - np.dot(L[i, :i], y[:i])

    # Обратная подстановка: решаем Ux = y
    x = np.zeros(n)
    for i in range(n - 1, -1, -1):
        x[i] = (y[i] - np.dot(U[i, i + 1:], x[i + 1:])) / U[i, i]

    return x
```
Решает систему линейных уравнений Ax=b, где матрица A уже разложена на
L*U (нижнюю и верхнюю треугольные матрицы) с помощью LU-разложения. Алгоритм включает два этапа: прямую подстановку для нахождения промежуточного вектора
y и обратную подстановку для вычисления x.  
Прямая подстановка: 1) Создается нулевой вектор y, который будет содержать промежуточное решение. 2) Вычисляется y[i] как правая часть b[i]  минус сумма уже вычисленных значений L[i; j] * y[j] для j < i.  
Обратная подстановка: 1) Создается нулевой вектор x, который будет содержать итоговое решение. 2) Вычисляется x[i] как y[i] минус сумма произведений элементов U[i; j] * x[j] для j > i , деленная на диагональный элемент U[i; i].
Возвращается вектор x, являющийся решением системы Ax=b.

#### Функция, выполняющая транспонирование матрицы
```
def transpose(J):
    rows, cols = J.shape
    JT = np.zeros((cols, rows))
    for i in range(rows):
        for j in range(cols):
            JT[j, i] = J[i, j]
    return JT
```
Транспонирует матрицу **J**. Выполняется с помощью двойного цикла, меняя местами строки и столбцы. Возвращает транспонированную матрицу.

#### Функция для добавления регуляризации к матрице
```
def regularization(JTJ, epsilon=1e-6):
    n = JTJ.shape[0]
    return JTJ + epsilon * np.eye(n)
```
Добавляет регуляризацию к матрице **JTJ** для улучшения численной стабильности.


#### Функция для решения системы линейных уравнений с использованием LU-разложения
```
def solve(A, b):
    L, U = lu_decomposition(A)
    return solve_lu(L, U, b)
```
Объединяет LU-разложение и решение системы, чтобы найти x для уравнения Ax=b. Это делается для повышения численной устойчивости решения линейных систем.

#### Функция для вычисления нормы вектора
```
def norm(v):
    return sum(x ** 2 for x in v) ** 0.5
```
Вычисляет Евклидову норму (длину) вектора.

#### Функция, реализующая метод Гаусса-Ньютона
```
def gauss_newton(true_vp, true_vq, true_masses, vp_obs, vq_obs, masses_obs, max_iterations=15, tolerance=1e-4):
    x = np.concatenate((vp_obs.flatten(), vq_obs.flatten(), masses_obs))
    for iteration in range(max_iterations):
        def residual_function(x):
            vp_obs_current = x[:true_vp.size].reshape(true_vp.shape)
            vq_obs_current = x[true_vp.size:true_vp.size + true_vq.size].reshape(true_vq.shape)
            masses_current = x[true_vp.size + true_vq.size:]
            return compute_residual(vp_obs_current, vq_obs_current, true_vp, true_vq, masses_current,
                                    true_masses)

        J = compute_jacobian(residual_function, x)
        residual = residual_function(x)
        error = norm(residual)
        print(f"Итерация {iteration + 1}, Ошибка: {error}")

        epsilon = 1e-6
        JT = transpose(J)
        JTJ = np.dot(JT, J)
        JTJ_reg = regularization(JTJ, epsilon)
        JTr = np.dot(JT, residual)
        L, U = lu_decomposition(JTJ_reg)
        delta_x = -solve_lu(L, U, JTr.flatten())

        x += delta_x

        if error < tolerance:
            print(f"Сходимость достигнута на {iteration + 1} итерации.")
            break

    vp_restored = x[:true_vp.size].reshape(true_vp.shape)
    vq_restored = x[true_vp.size:true_vp.size + true_vq.size].reshape(true_vq.shape)
    masses_restored = x[true_vp.size + true_vq.size:]

    true_error_vp = norm(vp_restored - true_vp)
    true_error_vq = norm(vq_restored - true_vq)
    true_error_mass = norm(masses_restored - true_masses)
    print(f'Итоговая ошибка относительно истинных значений: для vp: {true_error_vp}, для vq: {true_error_vq}, для mass: {true_error_mass}')

    return vp_restored, vq_restored, masses_restored
```
Начальные зашумленные значения параметров объединяются в один вектор **x**. 
В цикле выполняется следующее:
- Определяется функция невязки (**residual_function**), которая зависит от текущих значений **x**
- Вычисляется Якобиан **J** с использованием **compute_jacobian**
- Вычисляется текущая невязка (**residual**), её норма используется как метрика ошибки
- Матрица **JTJ** (градиенты) регуляризуется для повышения стабильности
- Решается линейная система **JTJΔx=−JTr**, чтобы найти поправку **Δx** к текущим параметрам **x**
- Параметры **x** обновляются
- Если норма невязки (**error**) меньше заданного значения **tolerance**, итерации завершаются
Восстановленные параметры **vp, vq, masses** извлекаются из **x**, и считается их ошибка относительно истинных значений.

### Визуализация
#### Функция init() 
Инициализирует графические объекты (линии и точки) для 3D-анимации движения объектов (Земли и Луны).

#### Функция update(num)
Обновляет положение графических объектов (линий и точек) на заданном кадре анимации.

#### Функция plot_3d_vp_vq(vq_restored)
Строит статический 3D-график траекторий движения объектов (Солнце, Земля, Луна).

## 2. Математические выкладки
#### Алгоритм Гаусса-Ньютона
Алгоритм Гаусса-Ньютона является модификацией метода Ньютона, адаптированной для решения задач нелинейной регрессии и минимизации суммы квадратов остаточных ошибок. В данном случае он применяется для восстановления параметров системы трех тел (Солнце, Земля, Луна).
Если задано m функций r = (r1, …, rm) (часто называемых невязками) от n переменных β = (β1, …, βn), при m ≥ n. Алгоритм Гаусса — Ньютона итеративно находит значения переменных, которые минимизируют сумму квадратов:
![img.png](img.png)  
Начав с некоторого начального приближения β(0), метод осуществляет итерации
![img_1.png](img_1.png)  
Здесь, если рассматривать r и β как вектор-столбцы, элементы матрицы Якоби равны:
![img_2.png](img_2.png)  
Если m = n, итерации упрощаются до
![img_3.png](img_3.png),
что является прямым обобщением одномерного метода Ньютона.
При аппроксимации данных, где целью является поиск параметров β, таких, что заданная модель функций y = f(x, β) наилучшим образом приближает точки данных (xi, yi), функции ri являются остаточными ошибками:
![img_4.png](img_4.png)
Тогда метод Гаусса — Ньютона можно выразить в терминах якобиана J_f функции f
![img_5.png](img_5.png)

![img_6.png](img_6.png) является псевдообратной матрицей к J_f.

Также для повышения устойчивости вычислений (в случае плохо обусловленной матрицы JT) применяется регуляризация.
Это модифицирует нормальные уравнения:
![img_9.png](img_9.png),
где ϵ>0 — параметр регуляризации, а I — единичная матрица.

#### LU-разложение

LU-разложение — это метод разложения квадратной матрицы 
A на произведение двух матриц: нижней треугольной матрицы 
L и верхней треугольной матрицы U. Это важный инструмент для решения систем линейных уравнений, нахождения детерминанта матрицы и инвертирования матриц.

Для матрицы A размерности n×n можно найти такие матрицы L и U, что A = LU, где
- L — это нижняя треугольная матрица с единичными диагональными элементами 
![img_10.png](img_10.png)  
- U — это верхняя треугольная матрица  
![img_11.png](img_11.png)  
LU-разложение используется для упрощения решения системы линейных уравнений Ax=b, где 
A — матрица коэффициентов, 
x — вектор неизвестных, а 
b — вектор правых частей.
Преимущество LU-разложения состоит в том, что его можно использовать для решения системы 
Ax=b следующим образом:
1. Разложение: сначала матрица A представляется как произведение матриц L и U.
2. Решение: затем решается система линейных уравнений двумя шагами:
- Ly=b с помощью прямого метода подстановки (вектор y — промежуточное решение).
- Ux=y с помощью обратной подстановки.
Чтобы найти L и U, применяют последовательность операций Гаусса (метод исключений), ориентируясь на «обнуление» элементов ниже главной диагонали:
1. Начинаем с первого столбца матрицы A. Для этого:
![img_12.png](img_12.png)  
После этого вычитаем из оставшихся строк первые строки с учётом коэффициентов l_i1, чтобы получить верхнюю треугольную матрицу U.
2. Переходим ко второму столбцу и повторяем аналогичные операции. При этом новые элементы матрицы L и U вычисляются с использованием уже найденных элементов:
![img_13.png](img_13.png)  
Этот процесс продолжается до тех пор, пока не будет завершено разложение на треугольные матрицы.

## 3. Результаты
![img_14.png](img_14.png)График траекторий движения тел по восстановленным координатам.

![img_15.png](img_15.png)
Восстановленные параметры

Алгоритм продемонстрировал быструю сходимость (всего за 2 итерации).
Восстановленные значения параметров очень точно соответствуют истинным, с относительными ошибками на уровне 10^(-11).
Восстановленные массы практически идентичны истинным значениям. Разница составляет порядка 10^(-7).

 